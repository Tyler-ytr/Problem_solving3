# 问题求解3整理

## 动态规划

        动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的一个最优解，而不是最优解。

### 最优子结构： 

问题的最优解由相关子问题的最优解构成，而这些子问题可以独立求解。

证明最优子结构：“剪切-粘贴”。

### 实现：
+ 自顶向下的备忘算法（递归）（子问题不必完全求解时较快）
+ 自底向上的动态规划算法（循环）（一般较快）

### 重构解
每一次记录下子问题的最优解的结构


### 解题思考过程
+ 状态的表示
+ 状态间的转移（转移方程）
+ 解的表达
+ 边界条件
+ 计算顺序

### 例：
+ 钢材切割问题（左边第一刀和右边剩下的）
+ 矩阵链乘法
+ 最长公共子序列问题（LCS）（考虑X和Y对后一个是否相等）
+ 最优二叉搜索树（伪关键字）
+ 最长递增子列（LIS）（LCS（A，SORT（A））；或者dp计算以A[i]结尾的子列的最大长度）


## 贪心
        贪心算法每一步都作出当时看起来最佳的最优解，希望这样的选择能得到全局最优解。
### 最优子结构（同上）

### 贪心选择性质
我们可以通过做出局部最优（贪心）选择来构造全局最优。即进行选择的时候，我们直接作出在当前问题汇总看来最优的选择，而不必考虑子问题的解。


### 算法设计步骤
+ 将最优化问题转化为这样的形式：对齐作出一次选择之后，只剩下一个子问题需要求解。
+ 证明作出贪心选择后，原问题总是存在最优解，即贪心选择是安全的。（替换法）
+ 证明作出贪心选择后，剩余的子问题满足性质：其最优解和贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。

### 例：
+ 活动选择问题（总是选择最早结束的）
+ 分数背包问题（01背包问题不行）
+ 赫夫曼编码（找当前频率最低的两个合成一个新的结点）

## 图的基本概念
好多啊不想整理嘤嘤嘤

## 并查集
### 三个基本操作
+ MAKE-SET(x)：建立一个新的集合，唯一成员（因而是代表）是x；
+ UNION(x, y)：将包含x和y的两个动态几何合并为一个新的集合；
+ FIND-SET(x)：返回一个指针，指向包含x的唯一集合的代表。

### 链表表示
每个链表有head和tail；

链表中每个成员有key，prev（指向head），next

时间复杂度：
+ MAKE-SET O(1)
+ FIND-SET O(1)
+ UNION（简单实现） O(n)

### 简单加权合并启发式策略
+ 将较小的链表挂到较大的链表上

### 不相交集合森林
使用有根树来表示集合。
每棵树表示一个集合，树的根结点是该集合的代表元。
执行UNION操作时将两棵树的树根合并。
实现时可以用到两种改进运行时间的启发式策略。

（一）按秩合并

类似链表的加权合并启发式策略。为了易于分析，对于每个结点，维护一个秩，表示该结点高度的一个上界。

UNION操作

+ 如果根的秩不同，则让较大秩的根成为较小秩的根的父结点，但秩本身保持不变；
+ 如果根的秩相同，则任意选择两个中的一个作为父结点，并使它的秩+1

（二）路径压缩
+ 在FIND-SET操作中是查找路径中的每个结点直接指向根，不改变任何结点的秩。

伪代码：

        MAKE-SET(x)
        x.p = x
        x.rank = 0

        FIND-SET(x)
        if x != x.p
            x.p = FIND-SET(x.p)
        return x.p

        UNION(x, y)
        LINK(FIND-SET(x), FIND-SET(y))

        LINK(x, y)
        if(x.rank > y.rank)
            y.p = x
        else x.p = y
        if(x.rank == y.rank)
            y.rank++

### 例：
+ 确定无向图的连通分量

## 树


## 图的表示和遍历

## 单源最短路径算法

## 多源最短路径算法

## 图的连通度

## 旅行问题

## 图中的匹配与覆盖

## 最大流算法
